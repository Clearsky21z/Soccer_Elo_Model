<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="John Zhang">

<title>Global Elo Model for European Football</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="paper_files/libs/clipboard/clipboard.min.js"></script>
<script src="paper_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="paper_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="paper_files/libs/quarto-html/popper.min.js"></script>
<script src="paper_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="paper_files/libs/quarto-html/anchor.min.js"></script>
<link href="paper_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="paper_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="paper_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="paper_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="paper_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Global Elo Model for European Football</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>John Zhang </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1 Introduction</h2>
<p>Measuring club strength across European football leagues is non-trivial. Domestic league tables reflect performance within a single competition and season, while UEFA country and club coefficients aggregate results across tournaments but are slow to react and are not directly interpretable as team-level strengths. For applications such as forecasting match outcomes or comparing clubs across leagues, we would like a single, dynamically updated rating system that</p>
<ul>
<li>tracks team strength within and across the “Big Five” leagues (England, Spain, Italy, Germany, France),</li>
<li>reacts quickly to new information in the current season,</li>
<li>still uses historical performance but progressively down-weights older seasons, and<br>
</li>
<li>is calibrated using a proper predictive scoring rule rather than ad hoc criteria.</li>
</ul>
<p>In this project I build a <strong>global multi-season Elo model</strong> for domestic league matches in the Big Five leagues from the 2015/16 season up to the current 2025/26 season. The model extends the standard Elo framework used in sports analytics in three main directions:</p>
<ol type="1">
<li><strong>Cross-league scaling:</strong> season-specific UEFA country coefficients are used as league-level offsets so that teams from stronger leagues are, on average, rated higher than teams from weaker leagues.</li>
<li><strong>Multi-season dynamics:</strong> ratings are shrunk toward a global baseline between seasons, and newly promoted teams start below that baseline to reflect the gap between top and lower divisions.</li>
<li><strong>Recency and current-season emphasis:</strong> older seasons are down-weighted via an explicit relevance function, and the rating updates for the current season use an inflated <span class="math inline">\(K\)</span>–factor so that ratings respond more aggressively to recent results.</li>
</ol>
<p>Model hyperparameters are chosen by minimising a <strong>relevance-weighted Brier score</strong> for match outcomes on a held-out test set, using a box-constrained quasi-Newton optimiser. The final output is an end-of-sample global ranking of clubs in Elo units together with an estimate of out-of-sample predictive accuracy.</p>
<hr>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">2 Methodology</h2>
<section id="data-and-preprocessing" class="level3">
<h3 class="anchored" data-anchor-id="data-and-preprocessing">2.1 Data and preprocessing</h3>
<p>The dataset consists of match-level results for the top domestic divisions in England, Spain, Italy, Germany and France. For each league, seasons are stored as separate files, with one row per match and at least the following variables:</p>
<ul>
<li>calendar date of the match,</li>
<li>home and away team identifiers,</li>
<li>full-time home and away goals, and</li>
<li>full-time result, coded as home win, draw or away win.</li>
</ul>
<p>Each match is associated with a season label of the form <code>"YYYY/YY"</code> (for example, <code>2015/16</code>) and a league label (for example, <code>"england"</code>). The dataset is ordered chronologically by season start year, season and date. In addition, for each season and league, I construct a <strong>league strength offset</strong> using UEFA country coefficients: denote by <span class="math inline">\(c_{\ell,s}\)</span> the average coefficient of league <span class="math inline">\(\ell\)</span> in season <span class="math inline">\(s\)</span>, and treat this as an exogenous indicator of the underlying strength of that competition.</p>
<p>For each match <span class="math inline">\(i\)</span>, I therefore observe:</p>
<ul>
<li>season <span class="math inline">\(s_i\)</span> and corresponding start year <span class="math inline">\(t_i\)</span> (the first four digits of the season label),</li>
<li>league <span class="math inline">\(\ell_i\)</span>,</li>
<li>home and away teams <span class="math inline">\(h_i\)</span> and <span class="math inline">\(a_i\)</span>,</li>
<li>full-time result <span class="math inline">\(Y_i \in \{\text{H},\text{D},\text{A}\}\)</span>,</li>
<li>league offset <span class="math inline">\(\delta_{\ell_i,s_i}\)</span> derived from the UEFA coefficient <span class="math inline">\(c_{\ell_i,s_i}\)</span>.</li>
</ul>
<p>The ordered collection <span class="math inline">\(\{(h_i,a_i,s_i,t_i,\ell_i,Y_i,\delta_{\ell_i,s_i})\}_{i=1}^N\)</span> forms the input to the Elo model.</p>
<hr>
</section>
<section id="elo-rating-model" class="level3">
<h3 class="anchored" data-anchor-id="elo-rating-model">2.2 Elo rating model</h3>
<p>The model assigns to each team <span class="math inline">\(j\)</span> at time <span class="math inline">\(i\)</span> an Elo rating <span class="math inline">\(R_{j,i}\)</span> measured in points. At the beginning of the dataset all teams share a common baseline rating <span class="math inline">\(R_0 = 1200\)</span>.</p>
<p>For a given match <span class="math inline">\(i\)</span> between home team <span class="math inline">\(h_i\)</span> and away team <span class="math inline">\(a_i\)</span>, with pre-match ratings <span class="math inline">\(R_{h_i,i}\)</span> and <span class="math inline">\(R_{a_i,i}\)</span>, the model incorporates:</p>
<ul>
<li>a <strong>home advantage</strong> <span class="math inline">\(H\)</span> (fixed at 100 Elo points), and<br>
</li>
<li>a <strong>league offset</strong> <span class="math inline">\(\delta_{\ell_i,s_i}\)</span> common to both teams, derived from the UEFA coefficient.</li>
</ul>
<p>The expected home “score” is defined using the standard Elo logistic link</p>
<p><span class="math display">\[
E_{h_i,i} \;=\; \frac{1}{1 + 10^{-\,(R_{h_i,i} + H + \delta_{\ell_i,s_i} - (R_{a_i,i} + \delta_{\ell_i,s_i}))/400}}.
\]</span></p>
<p>Because domestic matches involve two teams from the same league in the same season, the offset <span class="math inline">\(\delta_{\ell_i,s_i}\)</span> cancels algebraically inside the parentheses; however, it remains in the formulation so the framework can be extended to cross-league fixtures (for example, European competitions) where the offsets differ.</p>
<p>The model encodes the observed full-time result <span class="math inline">\(Y_i\)</span> as a home score</p>
<p><span class="math display">\[
S_{h_i,i} =
\begin{cases}
1   &amp; \text{if } Y_i = \text{H (home win)},\\[4pt]
0.5 &amp; \text{if } Y_i = \text{D (draw)},\\[4pt]
0   &amp; \text{if } Y_i = \text{A (away win)},
\end{cases}
\]</span></p>
<p>and the away score as <span class="math inline">\(S_{a_i,i} = 1 - S_{h_i,i}\)</span>. After the match, ratings are updated according to</p>
<p><span class="math display">\[
R_{h_i,i+1} \;=\; R_{h_i,i} + K_{\text{eff},i}\,\bigl(S_{h_i,i} - E_{h_i,i}\bigr),
\]</span></p>
<p><span class="math display">\[
R_{a_i,i+1} \;=\; R_{a_i,i} + K_{\text{eff},i}\,\bigl(S_{a_i,i} - (1 - E_{h_i,i})\bigr),
\]</span></p>
<p>where <span class="math inline">\(K_{\text{eff},i}\)</span> is a match-specific effective <span class="math inline">\(K\)</span>–factor that controls how quickly ratings react to the result. All ratings for other teams remain unchanged at time <span class="math inline">\(i+1\)</span>.</p>
<hr>
</section>
<section id="multi-season-dynamics-shrinkage-and-promoted-teams" class="level3">
<h3 class="anchored" data-anchor-id="multi-season-dynamics-shrinkage-and-promoted-teams">2.3 Multi-season dynamics: shrinkage and promoted teams</h3>
<p>To prevent ratings from drifting arbitrarily over long time horizons and to reflect changes in team quality between seasons, I introduce two mechanisms at season boundaries.</p>
<p>Let <span class="math inline">\(s\)</span> index season and <span class="math inline">\(t(s)\)</span> be its start year (for example, <span class="math inline">\(t(2015/16) = 2015\)</span>). At the end of season <span class="math inline">\(s\)</span>, suppose team <span class="math inline">\(j\)</span> has rating <span class="math inline">\(R_{j,\text{end}(s)}\)</span>. Before the first match of season <span class="math inline">\(s+1\)</span>, its <strong>carried-over rating</strong> is shrunk toward the global baseline <span class="math inline">\(R_0\)</span> via</p>
<p><span class="math display">\[
R_{j,\text{start}(s+1)}^{\text{carried}} \;=\; R_0 + \lambda \,\bigl(R_{j,\text{end}(s)} - R_0\bigr),
\]</span></p>
<p>where <span class="math inline">\(0 \le \lambda \le 1\)</span> is a <strong>shrinkage parameter</strong>:</p>
<ul>
<li><span class="math inline">\(\lambda = 1\)</span> corresponds to full carry-over with no regression to the mean;</li>
<li><span class="math inline">\(\lambda = 0\)</span> resets all teams to the baseline at the start of each season;</li>
<li>intermediate values partially preserve past performance while pulling ratings back toward <span class="math inline">\(R_0\)</span>.</li>
</ul>
<p>Teams that are present in the previous season use <span class="math inline">\(R_{j,\text{start}(s+1)}^{\text{carried}}\)</span> as their starting rating.</p>
<p>For newly promoted teams or teams that appear for the first time in the dataset in season <span class="math inline">\(s\)</span>, there is no carried-over rating. These teams start below the baseline at</p>
<p><span class="math display">\[
R_{j,\text{start}(s)} = R_0 - P,
\]</span></p>
<p>where <span class="math inline">\(P \ge 0\)</span> is a <strong>promotion penalty</strong>. This reflects the empirical fact that teams coming up from a lower division typically have lower underlying strength than incumbent top-division clubs.</p>
<p>Thus, at the start of each season, every team either:</p>
<ul>
<li>inherits a shrunken rating from the previous season (if it existed previously), or</li>
<li>is treated as new/promoted and assigned the penalised starting rating <span class="math inline">\(R_0 - P\)</span>.</li>
</ul>
<hr>
</section>
<section id="recency-and-current-season-emphasis" class="level3">
<h3 class="anchored" data-anchor-id="recency-and-current-season-emphasis">2.4 Recency and current-season emphasis</h3>
<p>Historic results should inform ratings, but matches from many seasons ago should matter less than recent results. I capture this with two related mechanisms: relevance weights in the loss function, and a current-season boost in the <span class="math inline">\(K\)</span>–factor.</p>
<section id="relevance-weights" class="level4">
<h4 class="anchored" data-anchor-id="relevance-weights">2.4.1 Relevance weights</h4>
<p>Let <span class="math inline">\(T\)</span> denote the start year of the most recent season in the dataset, and let <span class="math inline">\(t_i\)</span> be the start year of the season containing match <span class="math inline">\(i\)</span>. Define the <strong>season age</strong> of match <span class="math inline">\(i\)</span> as</p>
<p><span class="math display">\[
\text{age}_i = T - t_i.
\]</span></p>
<p>Then define a <strong>relevance weight</strong></p>
<p><span class="math display">\[
w_i = \rho^{\,\text{age}_i},
\]</span></p>
<p>where <span class="math inline">\(0 &lt; \rho &lt; 1\)</span> is a <strong>relevance decay parameter</strong>. Smaller values of <span class="math inline">\(\rho\)</span> down-weight older seasons more aggressively. These weights do not affect the Elo update itself; instead, they are used when evaluating model fit and tuning the hyperparameters (Section 2.5). Matches from the most recent season have <span class="math inline">\(\text{age}_i = 0\)</span> and thus <span class="math inline">\(w_i = 1\)</span>, while matches from older seasons have <span class="math inline">\(w_i &lt; 1\)</span>.</p>
</section>
<section id="current-season-boost-to-the-kfactor" class="level4">
<h4 class="anchored" data-anchor-id="current-season-boost-to-the-kfactor">2.4.2 Current-season boost to the <span class="math inline">\(K\)</span>–factor</h4>
<p>To further emphasise the current 2025/26 season in the rating dynamics, I let the effective <span class="math inline">\(K\)</span>–factor depend on whether a match belongs to the most recent season. Specifically, define</p>
<p><span class="math display">\[
K_{\text{eff},i} =
\begin{cases}
K \cdot c, &amp; \text{if } t_i = T,\\[4pt]
K,         &amp; \text{if } t_i &lt; T,
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(K &gt; 0\)</span> is the base <span class="math inline">\(K\)</span>–factor and <span class="math inline">\(c \ge 1\)</span> is a <strong>current-season multiplier</strong>. For matches in the current season, ratings therefore move <span class="math inline">\(c\)</span> times as much in response to the surprise term <span class="math inline">\((S_{h_i,i} - E_{h_i,i})\)</span> as they would in earlier seasons. This helps the global ranking adapt more quickly when a team’s underlying strength changes sharply in the present.</p>
<p>Together, the relevance weights <span class="math inline">\(\{w_i\}\)</span> and the current-season multiplier <span class="math inline">\(c\)</span> ensure that:</p>
<ul>
<li>older matches are discounted when assessing predictive performance, and<br>
</li>
<li>the ratings themselves are more sensitive to current-season outcomes.</li>
</ul>
<hr>
</section>
</section>
<section id="hyperparameter-estimation-via-relevance-weighted-brier-score" class="level3">
<h3 class="anchored" data-anchor-id="hyperparameter-estimation-via-relevance-weighted-brier-score">2.5 Hyperparameter estimation via relevance-weighted Brier score</h3>
<p>The global Elo model involves five key hyperparameters:</p>
<ul>
<li><span class="math inline">\(K\)</span>: the base <span class="math inline">\(K\)</span>–factor controlling the magnitude of rating updates;</li>
<li><span class="math inline">\(\lambda\)</span>: the inter-season shrinkage parameter;</li>
<li><span class="math inline">\(P\)</span>: the promotion penalty applied to new teams;</li>
<li><span class="math inline">\(\rho\)</span>: the relevance decay parameter for down-weighting old seasons;</li>
<li><span class="math inline">\(c\)</span>: the current-season <span class="math inline">\(K\)</span> multiplier.</li>
</ul>
<p>I estimate these hyperparameters by minimising a <strong>relevance-weighted Brier score</strong> on a held-out test set.</p>
<p>First, I randomly partition the <span class="math inline">\(N\)</span> matches into a training set <span class="math inline">\(\mathcal{T}_\text{train}\)</span> (70% of matches) and a test set <span class="math inline">\(\mathcal{T}_\text{test}\)</span> (30% of matches), using a fixed random seed to ensure reproducibility. For any proposed parameter vector <span class="math inline">\(\theta = (K,\lambda,P,\rho,c)\)</span>, I:</p>
<ol type="1">
<li><p>Run the Elo update sequentially over all matches, obtaining for each match <span class="math inline">\(i\)</span> an expected home score <span class="math inline">\(E_{h_i,i}\)</span> and an observed home score <span class="math inline">\(S_{h_i,i}\)</span>.</p></li>
<li><p>Compute relevance weights <span class="math inline">\(w_i = \rho^{\,\text{age}_i}\)</span> based on the season age.</p></li>
<li><p>Evaluate the <strong>relevance-weighted Brier scores</strong> on the training and test sets:</p>
<p><span class="math display">\[
\text{Brier}_\text{train}(\theta) =
\frac{\displaystyle\sum_{i \in \mathcal{T}_\text{train}} w_i \bigl(S_{h_i,i} - E_{h_i,i}\bigr)^2}
     {\displaystyle\sum_{i \in \mathcal{T}_\text{train}} w_i},
\]</span></p>
<p><span class="math display">\[
\text{Brier}_\text{test}(\theta) =
\frac{\displaystyle\sum_{i \in \mathcal{T}_\text{test}} w_i \bigl(S_{h_i,i} - E_{h_i,i}\bigr)^2}
     {\displaystyle\sum_{i \in \mathcal{T}_\text{test}} w_i}.
\]</span></p></li>
</ol>
<p>The goal is to find <span class="math inline">\(\hat\theta\)</span> that minimises <span class="math inline">\(\text{Brier}_\text{test}(\theta)\)</span> subject to simple box constraints reflecting plausible ranges for each parameter (for example, <span class="math inline">\(5 \le K \le 80\)</span>, <span class="math inline">\(0.5 \le \lambda \le 1\)</span>, <span class="math inline">\(0 \le P \le 200\)</span>, <span class="math inline">\(0.1 \le \rho \le 0.8\)</span>, <span class="math inline">\(1 \le c \le 3\)</span>). I treat <span class="math inline">\(\text{Brier}_\text{test}(\theta)\)</span> as a black-box function of <span class="math inline">\(\theta\)</span> and apply a box-constrained quasi-Newton optimisation algorithm (L-BFGS-B) to obtain an approximate minimiser</p>
<p><span class="math display">\[
\hat\theta = (\hat K, \hat\lambda, \hat P, \hat\rho, \hat c).
\]</span></p>
<hr>
</section>
<section id="final-model-and-club-rankings" class="level3">
<h3 class="anchored" data-anchor-id="final-model-and-club-rankings">2.6 Final model and club rankings</h3>
<p>Using the estimated hyperparameters <span class="math inline">\(\hat\theta\)</span>, I refit the model on the full dataset. This involves:</p>
<ol type="1">
<li>recomputing the season ages and relevance weights using <span class="math inline">\(\hat\rho\)</span>;</li>
<li>running the Elo updates sequentially over all matches with <span class="math inline">\(K = \hat K\)</span>, <span class="math inline">\(\lambda = \hat\lambda\)</span>, <span class="math inline">\(P = \hat P\)</span> and <span class="math inline">\(c = \hat c\)</span>; and</li>
<li>extracting for each match the expected home score <span class="math inline">\(\widehat{E}_{h_i,i}\)</span> and realised home score <span class="math inline">\(S_{h_i,i}\)</span>.</li>
</ol>
<p>The <strong>overall Brier score</strong> of the final model is then</p>
<p><span class="math display">\[
\text{Brier}_\text{overall} =
\frac{1}{N} \sum_{i=1}^N \bigl(S_{h_i,i} - \widehat{E}_{h_i,i}\bigr)^2,
\]</span></p>
<p>which summarises the average squared error of the predicted home score across all matches.</p>
<p>To produce a single rating for each club, I consider each team’s post-match ratings at all times and define its final Elo as the maximum rating it attains by the end of the sample. Formally, if team <span class="math inline">\(j\)</span> appears in the set of home teams with post-match ratings <span class="math inline">\(\{R_{j,i}^{\text{home,after}}\}\)</span>, I take</p>
<p><span class="math display">\[
\widehat{R}_j = \max_i R_{j,i}^{\text{home,after}},
\]</span></p>
<p>and order teams in descending order of <span class="math inline">\(\widehat{R}_j\)</span>. This yields a global ranking of clubs across the Big Five leagues at the end of the 2025/26 season that reflects:</p>
<ul>
<li>performance within each league over multiple seasons,</li>
<li>regression to the mean between seasons,</li>
<li>a penalty for newly promoted teams, and</li>
<li>a strong influence of recent and current-season results through both the relevance weights and the inflated current-season <span class="math inline">\(K\)</span>–factor.</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>